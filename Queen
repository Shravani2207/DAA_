# N-Queens Problem using Backtracking
def isSafe(board, row, col, n):
    # Check same column
    for i in range(row):
        if board[i][col] == 'Q':
            return False
    # Check upper left diagonal
    i, j = row, col
    while i >= 0 and j >= 0:
        if board[i][j] == 'Q':
            return False
        i -= 1
        j -= 1
    # Check upper right diagonal
    i, j = row, col
    while i >= 0 and j < n:
        if board[i][j] == 'Q':
            return False
        i -= 1
        j += 1
    return True
def solveNQueens(board, row, n):
    if row == n:
        for r in board:
            print(" ".join(r))
        print()
        return
    for col in range(n):
        if isSafe(board, row, col, n):
            board[row][col] = 'Q'
            solveNQueens(board, row + 1, n)
            board[row][col] = '.'  # Backtrack
# Driver Code
n = 4
board = [['.' for _ in range(n)] for _ in range(n)
print(f"Solutions for {n}-Queens:\n")
solveNQueens(board, 0, n)
Nice — I’ll go through the N-Queens backtracking code you posted line-by-line and explain exactly what each line does, so you can confidently explain it in viva.
I'll use the clean version you were given:
# N-Queens Problem using Backtracking

def isSafe(board, row, col, n):
    # Check same column
    for i in range(row):
        if board[i][col] == 'Q':
            return False

    # Check upper left diagonal
    i, j = row, col
    while i >= 0 and j >= 0:
        if board[i][j] == 'Q':
            return False
        i -= 1
        j -= 1

    # Check upper right diagonal
    i, j = row, col
    while i >= 0 and j < n:
        if board[i][j] == 'Q':
            return False
        i -= 1
        j += 1

    return True


def solveNQueens(board, row, n):
    if row == n:
        for r in board:
            print(" ".join(r))
        print()
        return

    for col in range(n):
        if isSafe(board, row, col, n):
            board[row][col] = 'Q'
            solveNQueens(board, row + 1, n)
            board[row][col] = '.'  # Backtrack


# Driver Code
n = 4
board = [['.' for _ in range(n)] for _ in range(n)]

print(f"Solutions for {n}-Queens:\n")
solveNQueens(board, 0, n)
________________________________________


# N-Queens Problem using Backtracking
A plain comment telling anyone reading the file what this program solves.
Function: isSafe
def isSafe(board, row, col, n):
Defines a function named isSafe that checks whether placing a queen at position (row, col) on board of size n is safe (i.e., no other queen attacks it). Parameters:
board: 2D list representing the chessboard ('Q' for queen, '.' for empty).
row, col: coordinates to check.
n: board size (n x n).
# Check same column
for i in range(row):
if board[i][col] == 'Q':
return False
Loops i from 0 to row-1. Because we place queens row by row top→down, only rows above current row can have queens.
if board[i][col] == 'Q': If any square in the same column above has a queen → conflict.
return False: Not safe; stop checking and return False.
# Check upper left diagonal
i, j = row, col
while i >= 0 and j >= 0:
if board[i][j] == 'Q':
return False
i -= 1
j -= 1
Sets i, j to start at the current position.
The while loop traverses the upper-left diagonal (decreasing both row and column).
If any square on that diagonal contains 'Q', return False (conflict).
Otherwise decrement i and j to move one step up-left until boundary.
# Check upper right diagonal
i, j = row, col
while i >= 0 and j < n:
if board[i][j] == 'Q':
return False
i -= 1
j += 1
Re-initialize i, j to current position.
This loop checks the upper-right diagonal (decreasing row, increasing column).
If any 'Q' found there, return False.
Continue moving up-right while inside board.
return True
If none of the checks found a conflicting queen, return True — the position (row, col) is safe.

Function: solveNQueens
def solveNQueens(board, row, n):
Defines the recursive backtracking function that tries to place queens row by row.
board: current board state.
row: index of current row where we need to place a queen.
n: board size.
if row == n:
for r in board:
print(" ".join(r))
print()
return
Base case: If row == n, we have placed queens on rows 0..n-1 → a full valid solution.
for r in board: print(" ".join(r)) prints the board row by row with spaces between cells (visual format).
print() prints a blank line between solutions.
return stops further recursion for this branch (we go back to find other solutions).
for col in range(n):
Loop over all columns in the current row to try placing a queen in each column.
if isSafe(board, row, col, n):
Call isSafe to check if position (row, col) is safe. If not safe, skip to next column.
board[row][col] = 'Q'
Place a queen at (row, col) (choose this option).
solveNQueens(board, row + 1, n)
Recurse to try placing queens in the next row (move forward). This explores all solutions that include the current placement.
board[row][col] = '.'  # Backtrack
After recursion returns, remove the queen — this is backtracking. It restores board to try the next column placement in the loop.

Driver code: set up & call
# Driver Code
n = 4
Sets board size n = 4. You can change n to find solutions for any N.
board = [['.' for _ in range(n)] for _ in range(n)]
Creates an n x n 2D list filled with '.' representing empty cells.
Uses list comprehension: inner ['.' for _ in range(n)] makes one row; outer repeats it n times.
print(f"Solutions for {n}-Queens:\n")
Prints a header, showing which n is being solved.
solveNQueens(board, 0, n)
Starts the backtracking from row = 0 (first row).
________________________________________
QUESTIONS
Q1. What is the N-Queens problem?
It is a problem of placing N queens on an N×N chessboard so that no two queens attack each other.
Q2. Which technique is used in this program?
Backtracking — try placing queens, and if a conflict happens, undo (backtrack) and try another position.
Q3. Why backtracking is used?
Because we explore all possible safe positions and backtrack when a position leads to conflict.
Q4. What does isSafe() function do?
It checks if placing a queen at a given (row, col) is safe by checking:
Same column
Upper left diagonal
Upper right diagonal
Q5. Why do we only check upper diagonals and column?
Because queens are placed row by row from top to bottom, so conflicts can only come from rows above.
Q6. What is backtracking step here?
board[row][col] = '.'
We remove the queen and try the next column.
Q7. What is the base condition?
if row == n:
This means all queens are placed successfully → print solution.
Q8. Time complexity?
Approximately O(N!) — exponential.
Q9. Why can't Greedy solve N-Queens?
N-Queens requires checking multiple possibilities, so Greedy may get stuck — Backtracking is required.
Q10. Real-life application of backtracking?
Solving puzzles (Sudoku, Crosswords)
Path finding
Decision making AI search
Constraint satisfaction problems
Q11. What is the board representation?
'.' = empty cell
'Q' = queen placed
Q12. Why recursion is used?
To explore all possible queen placements row by row.
Q13. What will this code print for N=4?
Two valid 4-queen board solutions.
Q14. Can we solve for N=2 or N=3?
No 
For N=2 and N=3 — no valid solutions exist.
Q15. Why do we place one queen per row?
Because each queen must be in a different row.
________________________________________
1. What is backtracking?
Backtracking is a general algorithmic technique for finding solutions to computational problems incrementally, by trying partial solutions and then abandoning them if they cannot be extended to a complete solution.
It systematically searches for a solution by exploring all possible options and backtracking when a solution path fails.
2. What are the applications of backtracking?
N-Queens Problem
1.	Sum of subsets problem
2.	Graph coloring
3.	Hamiltonian cycle
3. What is the N-Queens problem?
The N-Queens problem is to place N queens on an N×N chessboard such that no two queens attack each other. That means no two queens can be in the same row, column, or diagonal.
4. What is the 4-Queens problem
In the 4-Queens problem, we have to place 4 queens on a 4×4 chessboard so that no two queens attack each other.
The two possible solutions (represented as column positions for each row) are:
1.	(2, 4, 1, 3)
2.	(3, 1, 4, 2)
5. Explain the backtracking approach used in the N-Queens problem.
•	Place the first queen in the first row, first column.
•	Move to the next row and place a queen in the first available safe position (not attacked by previous queens).
•	If no safe position is found in that row, backtrack to the previous row and move that queen to the next possible column.
•	Repeat until all queens are placed safely or all possibilities are exhausted.
 6. What are the conditions for a queen to be under attack?
A queen is under attack if:
1.	Another queen exists in the same row.
2.	Another queen exists in the same column.
3.	Another queen exists on the same diagonal (both left and right).
7. Write the algorithm for the N-Queens problem.
Algorithm NQueens(n)
1. Place a queen in the leftmost column.
2. If all queens are placed, print the solution.
3. Try all columns in the current row:
     a) If the queen can be placed safely, place it.
     b) Recur to place the rest.
     c) If placing the queen doesn’t lead to a solution, remove it (backtrack).
4. If all columns have been tried and no placement works, return false.
 8. Write the function to check if a position is safe for placing a queen.
nction isSafe(board, row, col, N)
    For each i in 0 to row-1:
        if board[i][col] == 1:
            return False
    For (i, j) in upper-left diagonal:
        if board[i][j] == 1:
            return False
    For (i, j) in upper-right diagonal:
        if board[i][j] == 1:
            return False
    return True
9. Write the recursive function for solving N-Queens using backtracking.Function solveNQueens(board, row, N):
    if row >= N:
        printSolution(board)
        return True
    for col in 0 to N-1:
        if isSafe(board, row, col, N):
            board[row][col] = 1
            if solveNQueens(board, row+1, N):
                return True
            board[row][col] = 0   # Backtrack
    return False
10. What is the output for N = 4
The two valid configurations are:
Solution 1:         Solution 2:
. Q . .             . . Q .
. . . Q             Q . . .
Q . . .             . . . Q
. . Q .             . Q . .
11. What is the time complexity of the N-Queens problem?
The time complexity is O(N!), because there are N choices for the first queen, (N–1) for the next, and so on.
12. Why do we use recursion in backtracking?
Recursion allows the program to explore one solution path deeply, and automatically backtrack when a dead end is reached by returning from recursive calls.
13. What does “backtrack” mean in this context?
To “backtrack” means to undo the last step (removing a queen) and try the next possible option when a solution path fails.

