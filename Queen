# N-Queens Problem using Backtracking
def isSafe(board, row, col, n):
    # Check same column
    for i in range(row):
        if board[i][col] == 'Q':
            return False

    # Check upper left diagonal
    i, j = row, col
    while i >= 0 and j >= 0:
        if board[i][j] == 'Q':
            return False
        i -= 1
        j -= 1

    # Check upper right diagonal
    i, j = row, col
    while i >= 0 and j < n:
        if board[i][j] == 'Q':
            return False
        i -= 1
        j += 1

    return True
def solveNQueens(board, row, n):
    if row == n:
        for r in board:
            print(" ".join(r))
        print()
        return

    for col in range(n):
        if isSafe(board, row, col, n):
            board[row][col] = 'Q'
            solveNQueens(board, row + 1, n)
            board[row][col] = '.'  # Backtrack
# Driver Code
n = 4
board = [['.' for _ in range(n)] for _ in range(n)]
print(f"Solutions for {n}-Queens:\n")
solveNQueens(board, 0, n)
-----------------------------------------------------------------------------------------


Line-by-line explanation — 

def isSafe(board, row, col, n):
Defines a function named isSafe that checks whether placing a queen at board[row][col] is safe. 
Parameters:
board: 2D list (rows × cols) representing the board (each cell '.' or 'Q').
row, col: coordinates where we want to place a queen.
n: board size (number of rows/columns).
# Check same column
Comment: the next block will check whether any queen is already in the same column above the current row.
for i in range(row):
Loop over row indices 0 to row-1 (only the rows above the current one).
We only need to check previous rows because queens are placed one row at a time top → bottom.
if board[i][col] == 'Q':
If any of those cells in the same col contains 'Q', then there's a queen in the same column.
return False
If a queen is found in the same column above, placing here is unsafe — return False.

# Check upper left diagonal
 next check the diagonal that goes up and left from (row, col).
i, j = row, col
Initialize i and j to start at the current position. We'll walk up-left by decrementing both.
while i >= 0 and j >= 0:
Loop while indices stay within the board in the up-left direction.
if board[i][j] == 'Q':
If at any visited cell on that diagonal there is a queen...
return False
...placing at (row, col) would be attacked from that diagonal — so return False.
i -= 1
j -= 1
Move one step up-left (decrement row and column) and continue checking.

# Check upper right diagonal
Comment: next check diagonal going up and right.
i, j = row, col
Reset i and j to the starting position again.
while i >= 0 and j < n:
Move up (i -= 1) and right (j += 1) until we go outside the board
if board[i][j] == 'Q':
If a queen exists on this diagonal...
return False
Not safe — queen would be attacked
i -= 1#Move one step up
j += 1#Move one step to the right
return True
If we finish checking and find no queen, it's safe

def solveNQueens(board, row, n):
Defines a recursive function solveNQueens that tries to place queens starting from row to n-1.
Parameters:
board: current board state (2D list).
row: current row where we are attempting to place a queen.
n: board size.
if row == n:
Base case: if row == n, we've successfully placed queens on rows 0 through n-1 (all rows). 
for r in board:
Iterate over each row r in the board to print the solution.
print(" ".join(r))
Print that row as space-separated characters (e.g., . Q . .). This displays the board in a readable format.
print()
Print a blank line to separate multiple solutions visually.
return
Return from this recursive call — we found a solution and printed it. 
The caller will continue to search for more solutions (backtracking).

for col in range(n):
Loop through all columns in the current row,Try placing queen in each position (row, col)
if isSafe(board, row, col, n):
Check if it's safe to place a queen at (row, col) using the isSafe function described earlier.
board[row][col] = 'Q'
If safe, place a queen there by setting the board cell to 'Q'.
solveNQueens(board, row + 1, n)
Recurse: attempt to place queens in the next row. This explores deeper placements with the current queen fixed.
board[row][col] = '.'  # Backtrack
Backtrack step: after returning from recursion (whether it found solutions or not), remove the queen from (row, col) so we can try the next column.
This ensures the board state is restored for subsequent attempts.

# Driver Code
n = 4
Sets the board size n to 4. This means the program will search for 4-Queens solutions.
Change n to any integer ≥ 1 to solve other sizes.
board = [['.' for _ in range(n)] for _ in range(n)]
Create an n × n board represented as a list of lists. Each cell is initialized to '.' meaning empty. 
This is a nested list comprehension:
outer list: creates n rows,
inner: creates n columns each containing '.'.
print(f"Solutions for {n}-Queens:\n")
Prints a header like Solutions for 4-Queens: followed by an empty line.
solveNQueens(board, 0, n)
Starts the recursive backtracking by calling solveNQueens with the initial row = 0 (begin at the top row).
------------------------------------------------------------------------------------------------------------


QUESTIONS
Q1. What is the N-Queens problem?
It is a problem of placing N queens on an N×N chessboard so that no two queens attack each other.
Q2. Which technique is used in this program?
Backtracking — try placing queens, and if a conflict happens, undo (backtrack) and try another position.
Q3. Why backtracking is used?
Because we explore all possible safe positions and backtrack when a position leads to conflict.
Q4. What does isSafe() function do?
It checks if placing a queen at a given (row, col) is safe by checking:
Same column
Upper left diagonal
Upper right diagonal
Q5. Why do we only check upper diagonals and column?
Because queens are placed row by row from top to bottom, so conflicts can only come from rows above.
Q6. What is backtracking step here?
board[row][col] = '.'
We remove the queen and try the next column.
Q7. What is the base condition?
if row == n:
This means all queens are placed successfully → print solution.
Q8. Time complexity?
Approximately O(N!) — exponential.
Q9. Why can't Greedy solve N-Queens?
N-Queens requires checking multiple possibilities, so Greedy may get stuck — Backtracking is required.
Q10. Real-life application of backtracking?
Solving puzzles (Sudoku, Crosswords)
Path finding
Decision making AI search
Constraint satisfaction problems
Q11. What is the board representation?
'.' = empty cell
'Q' = queen placed
Q12. Why recursion is used?
To explore all possible queen placements row by row.
Q13. What will this code print for N=4?
Two valid 4-queen board solutions.
Q14. Can we solve for N=2 or N=3?
No 
For N=2 and N=3 — no valid solutions exist.
Q15. Why do we place one queen per row?
Because each queen must be in a different row.
________________________________________
1. What is backtracking?
Backtracking is a general algorithmic technique for finding solutions to computational problems incrementally,
by trying partial solutions and then abandoning them if they cannot be extended to a complete solution.
It systematically searches for a solution by exploring all possible options and backtracking when a solution path fails.
2. What are the applications of backtracking?
N-Queens Problem
1.	Sum of subsets problem
2.	Graph coloring
3.	Hamiltonian cycle
3. What is the N-Queens problem?
The N-Queens problem is to place N queens on an N×N chessboard such that no two queens attack each other.
That means no two queens can be in the same row, column, or diagonal.
4. What is the 4-Queens problem
In the 4-Queens problem, we have to place 4 queens on a 4×4 chessboard so that no two queens attack each other.
The two possible solutions (represented as column positions for each row) are:
1.	(2, 4, 1, 3)
2.	(3, 1, 4, 2)
5. Explain the backtracking approach used in the N-Queens problem.
•	Place the first queen in the first row, first column.
•	Move to the next row and place a queen in the first available safe position (not attacked by previous queens).
•	If no safe position is found in that row, backtrack to the previous row and move that queen to the next possible column.
•	Repeat until all queens are placed safely or all possibilities are exhausted.
 6. What are the conditions for a queen to be under attack?
A queen is under attack if:
1.	Another queen exists in the same row.
2.	Another queen exists in the same column.
3.	Another queen exists on the same diagonal (both left and right).
7. Write the algorithm for the N-Queens problem.
Algorithm NQueens(n)
1. Place a queen in the leftmost column.
2. If all queens are placed, print the solution.
3. Try all columns in the current row:
     a) If the queen can be placed safely, place it.
     b) Recur to place the rest.
     c) If placing the queen doesn’t lead to a solution, remove it (backtrack).
4. If all columns have been tried and no placement works, return false.
 8. Write the function to check if a position is safe for placing a queen.
nction isSafe(board, row, col, N)
    For each i in 0 to row-1:
        if board[i][col] == 1:
            return False
    For (i, j) in upper-left diagonal:
        if board[i][j] == 1:
            return False
    For (i, j) in upper-right diagonal:
        if board[i][j] == 1:
            return False
    return True
9. Write the recursive function for solving N-Queens using backtracking.Function solveNQueens(board, row, N):
    if row >= N:
        printSolution(board)
        return True
    for col in 0 to N-1:
        if isSafe(board, row, col, N):
            board[row][col] = 1
            if solveNQueens(board, row+1, N):
                return True
            board[row][col] = 0   # Backtrack
    return False
10. What is the output for N = 4
The two valid configurations are:
Solution 1:         Solution 2:
. Q . .             . . Q .
. . . Q             Q . . .
Q . . .             . . . Q
. . Q .             . Q . .
11. What is the time complexity of the N-Queens problem?
The time complexity is O(N!), because there are N choices for the first queen, (N–1) for the next, and so on.
12. Why do we use recursion in backtracking?
Recursion allows the program to explore one solution path deeply, and automatically backtrack when a dead end is reached by returning from recursive calls.
13. What does “backtrack” mean in this context?
To “backtrack” means to undo the last step (removing a queen) and try the next possible option when a solution path fails.

